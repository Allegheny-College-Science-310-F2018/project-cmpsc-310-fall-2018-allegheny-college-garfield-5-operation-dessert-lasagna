# Project Report
# Group members: Jordan Durci, Noah Stape, and Alex Yarkosky

## Motivation

Our motivation for doing this as our project first and foremost comes from our collective enjoyment of video games. We have also had those moments when we complained about the AI in a game not being good enough and with this project, we will surely get a better idea of the process of creating AI in a game and see if we really had much room to complain or if we actually might be able to make a better AI than the ones that we were disappointed by. Similar concerns can briefly be found in Amit's Game Programming Information below in the Resources section. Regardless of our experience, the video game industry is always looking to improve in all aspects with the games being released, and this is the beginning into the kind of work needed to make those advancements from game to game. Furthermore, the types of problems we hope to look into are able to be applied outside of video games in much more generic contexts and then reapplied to the specifics of another area of programming entirely. Our efforts in making this project will also lend to us having experience desirable nonetheless the path taking in getting those experiences.
We also specifically chose to make a game as it gave us the ability to work with multiple AI techniques and gain a more broader sense of experience. We also wanted to get more experience with Unity as felt we could be more familiar with it and this let us work with it in 2D as opposed to previous experience with it only in 3D. Ultimately, we decided that this project would give us the kinds of experiences we would like to gain one way or another and hence it coincided well with the requirements of the project.
Our experiences with the Unity 3d project were conflicting. We knew that if we understood Unity better, that we would have had more fun, and less difficulty with that lab. We also were unable to work on something that was actually very interesting. Sure the top-down shooter that we worked on was useful and interesting, but we lacked personal investment in it. With this project, were definitely more invested in our concept for the game. We have worked on it consistently for weeks, and despite some issues, we still have worked hard on creating something that is ours.

## Background

Throughout the process of making our game, we found many resources available to help us along our path. We found tutorials on how to implement sprites and animations into Unity 2d. We found tutorials on how to setup our initial level and test workspace. We already knew a bit about Unity and how some of the built in components work because of our previous Unity 3d lab, so we were able to catch on pretty quickly. We also took inspiration from various sources to work on the movement of our enemies and our playable characters.
For the movement of our enemies, specifically the grumperfly, we implemented Aron Granburg's "A* Pathfinding Project." This project was incredibly useful for our project, and was our main implementation of AI. This project has a forum and blog, and is very well documented, so I was able to solve any problem that we ran into. Aron Granburg has many tutorials as well on how to implement the project in Unity. We still had a fair bit of difficulty on some points, as the algorithm does not have direct support for a platformer in Unity 2d. Having gravity in a 2d world is not supported. We had to figure this out ourselves, as well as the best way to keep the AI and the sprite moving together.
There were a few implementations of movement that we found, like making the grumpa's move back and forth between two points.
In general, despite us working on the majority of the project as individuals, we were inspired by various sources and tutorials across the internet to complete our project. Without some outside assistance, we would have been unable to create the project we intended on creating.
BRESENHAMAMAMAMAMAM BACKGROUND:


## Work Accomplished

Implementing the A* Pathfinding Project and getting it working as desired, was far more difficult than we expected. After many hours of troubleshooting and implementing minor changes, we were able to import it, create an accurate grid-graph, and actually apply it to our enemies. The grumperflies use the A* search algorithm to avoid obstacles and travel the fastest path to the character. We ran into an issue when we added colliders to the grumperflies, as the AI controller and the sprite were often knocked away from each other. This caused a separation between the AI and the sprite, so the grumperfly wouldn't actually fly to the proper location. This was solved by removing their colliders and letting them move without collision. The potential issue here is that they may fly through wall or the ground, but they actually couldn't because of the search algorithm. The grid-graph did not allow the AI to move through any obstacles that we did not want it to.
After this, we attempted to add the algorithm to enemies that were actually impacted by gravity. Because the "A* Pathfinding Project" is not meant to be used on 2d platformers, were were unable to achieve this. If we created this 2d world on a 3d plane, we might have been able to accomplish this. So instead of having the grumpas pathfind, they just walk across the ground between two points. This adds an obstacle to the game, even if it was not their intended movement.
There are a fair amount of unused sprites and animations for these sprites. These are currently visible in the level, but have no function. We had many ideas that were stunted by them being too difficult or impossible for us to implement within the time period. These ideas' remnants exist within our project in case we want to look at them again.
BRESENHAMMAMAMAMAMAMAMAMAM:


## Results

(Should talk about what is actually in the game currently.)
We were able to achieve our basic goals of this project and provide the framework for most of the basis of the actual game.
Currently, the butterfly looking enemies, the grumperflies, both implement the pathfinding technique (green line in scene view) and the line of sight technique (blue line when spotted and red line when there is not a clear line of sight (i.e. terrain or obstacle crosses the line between the player character and the enemy) in the scene view). it should also be noted that each grumperfly either targets Armin or Lloyd for both the pathfinding and the line of sight. It should also be noted that the current implementation of the line of sight does not use or simulate Bresenham's algorithm as originally desired but instead just uses Unity to draw the lines. The entirety of the game exists with a test level of sorts with all of the assets being in it even if they are not fully implemented. It might be obvious, but it should still be said that it is indeed possible to move the characters around the test level with Armin only being able to move whilst in the air as he jumps and Lloyd continuing to move after he is first moved, continuing in one direction until changed by the user. We also have many left over assets and features that we were unable to implement in our given amount of time. We might come back to these in the, as we already have a foundation to work upon.
While we did have an endgame sequence in mind, our game currently does not have that. What is available to play is more like a test environment. The game functions within Unity, but is not a complete project. Our work on the project is clearly visible within this test environment however.
(What work already exists on topic? Refer back to paper mentioned in proposal.)
## Conclusion

(Overview, what was learned, challenges, rewards.)
We learned a lot of valuable information through this project.  We learned a solid amount about working in Unity, especially on how to implement the A* pathfinding and line of sight algorithms.  Beyond that, we also learned a lot about animation in Unity2D, as opposed to Unity3D, and how  to use animation to activate specific components.  The project also gave us a wider knowledge base in regards to C# as a programming language.  The most important thing we learned was to use the proper GitHub Workflow.  We faced a number of challenges in this project, though.  We ran into a number of difficulties with merge errors, as Unity would often make changes upon opening that would lead to merge errors and conflicts.  At one point in the development of the game, we resolved a conflict improperly, leading to the entire scene getting corrupted.  This meant that we had to revert to a previous commit's version of the scene in order to continue working.  We also faced some difficulties due to our inexperience with Unity and C# on the whole.  The most rewarding parts of the process were the ability to see each of our initial ideas about what would be in the final game implemented.  When we got pathfinding on the grumperflies working, it was huge.  When we got Armin jumping to move, and punching, it felt great.  Each small piece of the game that was implemented was another reward in and of itself.
